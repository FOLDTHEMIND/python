<Python Notes>

EX2300 Information:
192.168.86.49
pyclass
Pyclass2025!


[Virtual Environments]
	Open WSL
	source py314_venv/scripts/activate to activate VENV
	Can use python3 to open python interpreter (basically like a live python script)
	Create Python VENV:
	python3.12 -m venv venv_name

[Using git]
	Need to be in repo folder (c:\users\tyler\VENV\)
	git status - check if there are any changes
	git add . - stage any changes
	git commit -m "Description of change" - commit changes and add comment
	git push - pushes changes to GitHub repo


[Functions]
	input() - Prompt for user input
	print() - print text or variable
	dir() - find out what methods a variable offers (i.e. string supports .upper(), .split(), etc.)
	help(var.method) - shows how to use a method
	len(list) - check the length of a list
	list(range(n)) - generate a list of n numbers starting from 0
	var in list - to check if given variable is in a list. returns true/false


[Embedding variable in string]
	Use f string and put your variable in {}
	f"This is a string with a variable: {my_var}"
	Use r string for raw string
	r"c:\users\tyler\documents"


[Indentation]
	Colon (:) indicates an indented code block
	Indentation always starts with four spaces


[File Operations]
	f = open("show_version.txt")
	data = f.read()
	f.close()

	open("filename.txt") - open a file; "r" mode for read (default), "w" mode for write, "a" mode for append
	.read() - read the entire file as a string
	.readline() - read one line at a time
	.readlines() - read all of the lines of the file into a list
	.seek(int) - jump to a specific line; line 0 for beginning of file
	.write("Text") - write to a file
	.flush() - push write changes to a file
	.close() - close file when done


[Context Managers]
	with open("filename.txt", mode = "r") as f:
		data = f.read()

	with - keyword to use context manager


[Generator Example]
	def gen(n):
		i = 0
		while i < n:
			yield i
			i += 1
	OR
	my_generator = (for x in range(n))


[Lists, Sets, and Dictionaries]
	Lists use [] and are ordered with indices. You can have any combination of different types of variables
	list.append("value") to add a value to the end of a list

	Sets use {} and are unordered groups of variables. You can not have duplicates in a set. Sets are immutable
	set.add("value") to add a variable to a set
	set.update("set2") to combine two sets
	set.remove("value") to remove a variable from a set (use .discard() to remove without generating an exception)
	"set1 | set2" to union two sets together. This doesn't change them but returns the combined set with no duplicates
	"set1 & set2" to retrieve the intersection of the two sets
	"set1 ^ set2" to retrieve all values that are not contained in both sets

	Dictionaries use {} with key:value pairs
	my_dict = {
	"rtr_1": "10.1.100.1",
	"rtr_2": "10.2.100.1",
	"rtr_3": "10.3.100.1"}
	my_dict["rtr_3"] to retrieve a value. You can also use .get()
	my_dict["rtr_3"] = "10.3.100.2" to reassign value
	.print() to print out all key:value pairs
	Printing over dictionary in for loop returns the keys. Use my_dict.values() in your loop to get values when printing
	.items() in your for loop to get both key and value when printing
	.pop() to remove key and return value (can assign to a variable)
	.update() method to combine dictionaries


[Exception Handling]
	Use try: except blocks to handle exceptions
	You can assign your exception to a variable ("except as e:") so that you can reference it
	Use the raise keyword to raise the exception again (if you still want your program to crash)
	Use the try: except finally block to include code that will occur whether there is an exception or
	not. Typically cleanup operations
	
	
[Regular Expression]
	import re - import the regular expression library
	re.search(pattern, data) - search for the specified string in the given dataset. returns boolean if present or not
	Prefix your string with 'r' to make it a raw string. Turns off python special characters (\n, \t, etc.)
	re.findall(pattern, data) to find multiple occurences of your pattern, instead of just matching the first one
	re.escape(data) function to escape all special characters (converts all of them to literal characters with a \)
	.group(0) - determine what string was matched for
	.groupdict() to get a dictionary of your names capture groups and their values
	.group(name) to get value of specified named capture group (instead of using .group(0), .group(1), etc.)
	
	Flags
	flags=re.MULTILINE (or re.M) to the end of your re.search to make each line get its own ^ and $
	flags=re.DOTALL (or re.D) to make the . special character include \n
	
	Regex key:
	. any single character
	.* any character repeated zero or more times
	.+ any character repeated one or more times
	.? any character repeated zero or one times
	\s whitespace character class
	\S non-whitespace character class
	\w any word character (a-z, A-Z, 0-9, _)
	\d any digit character
	() for creating a capture group that can be referenced. Include ?P<name> at the beginning of your group to name it
	(|) logical OR
	^ beginning of line
	$ end of line
	\ escape sequence
	[] constructing custom class
	*? convert to non-greedy
	+? convert to non-greedy
	
	Examples
	IP Address pattern: (\d+\.\d+\.\d+\.\d+) OR ([\d\.]+)
	MAC Address pattern: (\w+\.\w+\.\w+) OR ([\w+\.]+)
	
	
[Functions]
	Positional arguments:
	def my_function(arg1, arg2):
		some_code
		return some_output
	Named arguments:
	def my_function(arg2=something, arg1=else):
		some code
		return some_output
	Functions follow LEGB when figuring out a variables value (Local, Enclosed, Global, Built-in)
	Prefix a list with * to pass a list's values to each argument (instead of passing the entire list to the first argument)
	Prefix a dictionary with ** to pass in the dictionary as key-value pairs (keys must match parameter names)
	Define your function with *args to allow any number of positional arguments. Creates a tuple with all args
	You can use **kwargs to accept a dictionary with any number of key-value pairs
	Lambda function format "lambda x: x**2"
	Think about it like "lambda (x): return x**2"
	Bind it to a variable "my_func = lambda x,y: x**y"
	
	
[Classes and Objects]
	A class is a blueprint for creating an object
	Define your class and its functions with the following syntax:
	class ClassName:
		def function1(self, parameter1, parameter2):
			code
		def function2(self, parameter):
			code
			
	Define the __init__ function to initialize your object and its parameters
	Static methods are used when you're creating a method that doesn't need to use the self parameter.
	Use the @staticmethod decorator to create one
	
	
[Data Classes]
	Allows you to create a Class boilerplate in simple form
	Use @dataclass tag. Need to import (from dataclasses import dataclass)
	Attributes with default values must be specified last
	Comes with __repr__ automatically (this is the same thing as __str__)
	@dataclass
	class NetDevice:
		device_type: str
		host: str
		username: str
		password: str
		version: str = "v1.0"
		

[Class Attributes]
	Attributes that are shared by all instances of the class
	Refer to the attribute using Class.Attribute (TelnetConn.conns in below example)
	class TelnetConn:
		conns = 0
			
			
[Inheritance & Super]
		Classes can inherit methods and attributes from parent classes. All classes inherit from the default object class
		class ConnectionClass:
			some code
		
		class SSHConnection(ConnectionClass):
			some code
		Use super(). to call a method from the parent class (i.e. super().__init__(attribute1, attribute2, etc.) to 
		call the parent dunder init method. Useful for augmenting dunder init for a child class
		Use super().__init__(*args, **kwargs) to allow for changes in the parent class
		
		
[Libraries and Python Path]
		To add a directory to your sys.path, use $PYTHONPATH.
		export PYTHONPATH=/directory/to/add
		

[Best Practices]
	Best practice is to seperate your reusable things (functions, classes, etc.) from main code
	if __name__ == "__main__":
	code
	Follow this order: Constants, Functions, Classes, [seperater], Main code
	Optional: include your main code in a function named main() and then just call that function
	Modules are usually python files that only contain reusable elements for you to import elsewhere
	Packages are directories containing multiple modules. __init__.py is a special file that automatically gets loaded from importing a package